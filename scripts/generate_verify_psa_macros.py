#!/usr/bin/env python3

"""Generate verify_psa_macros.c"""

# Copyright The Mbed TLS Contributors
# SPDX-License-Identifier: Apache-2.0
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import re

OUTPUT_TEMPLATE = '''\
/* Automatically generated by generate_verify_psa_macros.py. DO NOT EDIT. */

#include <stdio.h>

#include "psa/crypto.h"

{header}

#define hash_alg   PSA_ALG_SHA_256
#define mac_alg    PSA_ALG_CMAC
#define ka_alg     PSA_ALG_ECDH
#define kdf_alg    PSA_ALG_HKDF(PSA_ALG_SHA_256)
#define mac_length 4
#define group      0x2A
#define curve      0x2A
#define type       PSA_KEY_TYPE_RSA_PUBLIC_KEY

int main() {{
    int ret = 0;

    {tests}

    return ret;
}}
'''

HEADER_TEMPLATE = '''\
#ifdef {name}
#define SPEC_{name}{parameters} {expansion}
#else
#define {name}{parameters} {expansion}
#endif
'''

TEST_TEMPLATE = '''\
#ifdef SPEC_{name}
    if ({name}{parameters} != SPEC_{name}{parameters}) {{
        fprintf(stderr, "ERROR: %s doesn't match value in spec\\n", "{name}{parameters}");
        ret = 1;
    }}
#else
    printf("WARN:  %s is not defined\\n", "{name}{parameters}");
#endif
'''

TEST_DEFINED_TEMPLATE = '''\
#ifndef {name}
    printf("WARN:  %s is not defined\\n", "{name}{parameters}");
#endif
'''

class MacroCollector():
    """Collect PSA crypto macro definitions from C header(-like) files.

    1. Call `read_file` on the input header file(s).
    2. Call `write_file` to write ``psa_constant_names_generated.c``.

    Based on the MacroCollector in generate_psa_constants.py,
    but *just* different enough not to warrant inheriting anything from it.

    Should probably create a shared base class for the two of them at some point.
    """

    def __init__(self):
        self.macros = {}

    # "#define" followed by a macro name with or without parameters.
    # Grab the macro name in group 1, the parameters if any in group 2
    # and the expansion if any in group 3.
    _define_directive_re = re.compile(r'\s*#\s*define\s+(\w+)' +
                                      r'(?:\s+|(\([^)]*\))\s*)' +
                                      r'(.*)', re.DOTALL)
    _comment_re = re.compile(r'/\*.*?\*/|//.*')
    _trailing_whitespace_re = re.compile(r'(\s|\\\n)+$')

    def read_line(self, line):
        """Parse a C header line and record the identifier it defines if any.
        This function analyzes lines that start with "#define"
        (up to non-significant whitespace) and skips all non-matching lines.

        !!! Difference from generate_psa_constants.py !!!
        This function has to handle line continuations left intact by read_file
        """
        m = re.match(self._define_directive_re, line)
        if not m:
            return
        name, parameters, expansion = m.groups()
        if parameters is None:
            parameters = ''
        expansion = re.sub(self._comment_re, ' ', expansion)
        expansion = re.sub(self._trailing_whitespace_re, '', expansion)
        macro = (parameters, expansion)
        if expansion:
            self.macros[name] = macro
        else:
            self.macros.setdefault(name, macro)

    _nonascii_cr_re = re.compile(rb'[^\x00-\x7f\r]+')
    _continued_line_re = re.compile(rb'\\\r?\n\Z')
    def read_file(self, header_file):
        """Scan header file for macro definitions

        !!! Difference from generate_psa_constants.py !!!
        This function leaves the line continuations intact
        """
        for line in header_file:
            m = re.search(self._continued_line_re, line)
            while m:
                cont = next(header_file)
                line = line[:m.end(0)] + cont
                m = re.search(self._continued_line_re, line)
            line = re.sub(self._nonascii_cr_re, rb'', line).decode('ascii')
            self.read_line(line)

    def write_file(self, output_file):
        """Generate output from the gathered macros"""
        header = []
        tests = []

        for name, (parameters, expansion) in self.macros.items():
            macro = {'name' : name, 'parameters' : parameters, 'expansion' : expansion}
            if not expansion or '_IS_' in name or '_GET_' in name:
                tests.append(TEST_DEFINED_TEMPLATE.format_map(macro))
            else:
                header.append(HEADER_TEMPLATE.format_map(macro))
                tests.append(TEST_TEMPLATE.format_map(macro))

        output_file.write(OUTPUT_TEMPLATE.format(header='\n'.join(header), tests='\n'.join(tests)))

def generate_verify_psa_macros(header_file_names, output_file_name):
    collector = MacroCollector()
    for header_file_name in header_file_names:
        with open(header_file_name, 'rb') as header_file:
            collector.read_file(header_file)
    temp_file_name = output_file_name + '.tmp'
    with open(temp_file_name, 'w') as output_file:
        collector.write_file(output_file)
    os.replace(temp_file_name, output_file_name)

if __name__ == '__main__':
    if not os.path.isdir('programs') and os.path.isdir('../programs'):
        os.chdir('..')
    generate_verify_psa_macros(('scripts/data_files/psa_spec/crypto.h',
                                'scripts/data_files/psa_spec/specdef_values.rst'),
                               'programs/test/verify_psa_macros.c')
