#!/usr/bin/env python3

"""Generate a header file for a PSA Cryptography driver.
"""

# Copyright (C) 2020, ARM Limited, All Rights Reserved
# SPDX-License-Identifier: Apache-2.0
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# This file is part of mbed TLS (https://tls.mbed.org)

import argparse
import os
import re
import sys

import psa_crypto_driver_description

HEADER_HEADER = """/* PSA Crypto driver "{description}" header file */
/* Automatically generated by {generator_script}. Do not edit. */

#ifndef {guard_symbol}
#define {guard_symbol}

#ifdef __cplusplus
extern "C" {{
#endif

"""

HEADER_FOOTER = """
#ifdef __cplusplus
}}
#endif

#endif /* {guard_symbol} */
"""

class Function:
    def __init__(self, name, parameters, return_type='psa_status_t'):
        self.name = name
        self.parameters = parameters
        self.return_type = return_type

def dict_by_name(things):
    return dict((thing.name, thing) for thing in things)

INBUF = ['const uint8_t *', 'size_t']
OUTBUF = ['uint8_t *', 'size_t', 'size_t *']
INKEY = ['const psa_key_attributes_t *', *INBUF]

functions = dict_by_name([
    Function('init', []),
    Function('import_key', [*INKEY, *OUTBUF]),
    Function('destroy_key', [*INKEY]),
    Function('sign_hash', [*INKEY, 'psa_algorithm_t', *INBUF, *OUTBUF]),
])

def write_function(out, prefix, name):
    function = functions[name]
    parameters = ', '.join(function.parameters)
    if not parameters:
        parameters = 'void'
    out.write('{} {}_{}({});\n'
              .format(function.return_type, prefix, name, parameters))

def write_header_content(out, drv):
    for cap in drv.capabilities:
        for function in cap.functions:
            write_function(out, drv.prefix, function)

def _write_header_file_common(drivers, description, filename):
    guard_symbol = re.sub(r'[^0-9A-Z_]', '_',
                          os.path.basename(filename).upper())
    data = {
        'filename': filename,
        'generator_script': __file__,
        'guard_symbol': guard_symbol,
        'description': description,
    }
    with open(filename, 'w') as out:
        out.write(HEADER_HEADER.format(**data))
        for drv in drivers:
            write_header_content(out, drv)
        out.write(HEADER_FOOTER.format(**data))

def write_header_file(drv, filename=None):
    if filename is None:
        filename = drv.prefix + '.h'
    return _write_header_file_common([drv], drv.prefix, filename)

def write_shared_header_file(drivers, filename):
    description = '+'.join(drv.prefix for drv in drivers)
    return _write_header_file_common(drivers, description, filename)

def main():
    parser = argparse.ArgumentParser(description=__doc__, add_help=False)
    parser.add_argument('--output-file', '-o',
                        help="Name of the header file to generate (default: {PREFIX}.h)")
    parser.add_argument('input_file', metavar='INPUT',
                        help="driver description file in JSON format (default: stdin)")
    options = parser.parse_args()
    if options.input_file:
        drv = psa_crypto_driver_description.from_json_file(options.input_file)
    else:
        drv = psa_crypto_driver_description.from_json(json.load(sys.stdin))
    write_header_file(drv, options.output_file)

if __name__ == '__main__':
    main()
