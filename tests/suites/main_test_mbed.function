#line 1 "main_test_mbed.function"
SUITE_PRE_DEP
#define TEST_SUITE_ACTIVE

int verify_string( char **str )
{
    if( (*str)[0] != '"' ||
        (*str)[strlen( *str ) - 1] != '"' )
    {
        mbedtls_printf( "Expected string (with \"\") for parameter and got: %s\r\n", *str );
        return( -1 );
    }

    (*str)++;
    (*str)[strlen( *str ) - 1] = '\0';

    return( 0 );
}

int verify_int( char *str, int *value )
{
    size_t i;
    int minus = 0;
    int digits = 1;
    int hex = 0;

    for( i = 0; i < strlen( str ); i++ )
    {
        if( i == 0 && str[i] == '-' )
        {
            minus = 1;
            continue;
        }

        if( ( ( minus && i == 2 ) || ( !minus && i == 1 ) ) &&
            str[i - 1] == '0' && str[i] == 'x' )
        {
            hex = 1;
            continue;
        }

        if( ! ( ( str[i] >= '0' && str[i] <= '9' ) ||
                ( hex && ( ( str[i] >= 'a' && str[i] <= 'f' ) ||
                           ( str[i] >= 'A' && str[i] <= 'F' ) ) ) ) )
        {
            digits = 0;
            break;
        }
    }

    if( digits )
    {
        if( hex )
            *value = strtol( str, NULL, 16 );
        else
            *value = strtol( str, NULL, 10 );

        return( 0 );
    }

MAPPING_CODE

    mbedtls_printf( "Expected integer for parameter and got: %s\r\n", str );
    return( KEY_VALUE_MAPPING_NOT_FOUND );
}


/*----------------------------------------------------------------------------*/
/* Test Case code */

FUNCTION_CODE
SUITE_POST_DEP

#line !LINE_NO! "main_test_mbed.function"


/*----------------------------------------------------------------------------*/
/* Test dispatch code */

int dep_check( char *str )
{
    if( str == NULL )
        return( 1 );

DEP_CHECK_CODE
#line !LINE_NO! "main_test_mbed.function"

    return( DEPENDENCY_NOT_SUPPORTED );
}

int dispatch_test(int cnt, char *params[50])
{
    int ret;
    ((void) cnt);
    ((void) params);

#if defined(TEST_SUITE_ACTIVE)
    ret = DISPATCH_TEST_SUCCESS;

    // Cast to void to avoid compiler warnings
    (void)ret;

DISPATCH_FUNCTION
    {
#line !LINE_NO! "main_test_mbed.function"
        mbedtls_fprintf( stdout,
                         "FAILED\r\nSkipping unknown test function '%s'\r\n",
                         params[0] );
        fflush( stdout );
        ret = DISPATCH_TEST_FN_NOT_FOUND;
    }
#else
    ret = DISPATCH_UNSUPPORTED_SUITE;
#endif
    return( ret );
}


/*----------------------------------------------------------------------------*/
/* Main Test code */

#line !LINE_NO! "main_test_mbed.function"

int get_line( const char **test_data, char *buf, size_t len )
{
    // this function currently does not handle \r\r\n line terminators, but we
    // are hard-coding the test data inside the c file, so this should not
    // cause problems.

    size_t i;

    // if the string is empty fail and the destination remains unchanged
    if ( **test_data == '\0' )
         return( -1 );

    // copy character by character until capacity or eof is reached
    for( i = 0; i < len; i++ )
    {
        if( **test_data == '\n' ) {
            buf[i] = '\0';
            *test_data += 1;
            break;
        } else if( **test_data == '\0' ) {
            buf[i] = '\0';
            break;
        } else {
            buf[i] = **test_data;
            *test_data += 1;
        }
    }

     return( 0 );
}


int parse_arguments( char *buf, size_t len, char *params[50] )
{
    int cnt = 0, i;
    char *cur = buf;
    char *p = buf, *q;

    params[cnt++] = cur;

    while( *p != '\0' && p < buf + len )
    {
        if( *p == '\\' )
        {
            p++;
            p++;
            continue;
        }
        if( *p == ':' )
        {
            if( p + 1 < buf + len )
            {
                cur = p + 1;
                params[cnt++] = cur;
            }
            *p = '\0';
        }

        p++;
    }

    /* Replace newlines, question marks and colons in strings */
    for( i = 0; i < cnt; i++ )
    {
        p = params[i];
        q = params[i];

        while( *p != '\0' )
        {
            if( *p == '\\' && *(p + 1) == 'n' )
            {
                p += 2;
                *(q++) = '\n';
            }
            else if( *p == '\\' && *(p + 1) == ':' )
            {
                p += 2;
                *(q++) = ':';
            }
            else if( *p == '\\' && *(p + 1) == '?' )
            {
                p += 2;
                *(q++) = '?';
            }
            else
                *(q++) = *(p++);
        }
        *q = '\0';
    }

    return( cnt );
}

static int test_snprintf( size_t n, const char ref_buf[10], int ref_ret )
{
    int ret;
    char buf[10] = "xxxxxxxxx";
    const char ref[10] = "xxxxxxxxx";

    ret = mbedtls_snprintf( buf, n, "%s", "123" );
    if( ret < 0 || (size_t) ret >= n )
        ret = -1;

    if( strncmp( ref_buf, buf, sizeof( buf ) ) != 0 ||
        ref_ret != ret ||
        memcmp( buf + n, ref + n, sizeof( buf ) - n ) != 0 )
    {
        return( 1 );
    }

    return( 0 );
}

static int run_test_snprintf( void )
{
    return( test_snprintf( 0, "xxxxxxxxx",  -1 ) != 0 ||
            test_snprintf( 1, "",           -1 ) != 0 ||
            test_snprintf( 2, "1",          -1 ) != 0 ||
            test_snprintf( 3, "12",         -1 ) != 0 ||
            test_snprintf( 4, "123",         3 ) != 0 ||
            test_snprintf( 5, "123",         3 ) != 0 );
}

void test_case()
{
    /* Test suite data */
    const char *test_suite_data = TEST_DATA_CODE;

#line !LINE_NO! "main_test_mbed.function"

    /* Other Local variables */
    int ret, i, cnt;
    int total_errors = 0, total_tests = 0, total_skipped = 0;
    char buf[5000];
    char *params[50];
    void *pointer;
    int unmet_dep_count = 0;
    char *unmet_dependencies[20];

    /*
     * The C standard doesn't guarantee that all-bits-0 is the representation
     * of a NULL pointer. We do however use that in our code for initializing
     * structures, which should work on every modern platform. Let's be sure.
     */
    memset( &pointer, 0, sizeof( void * ) );
    if( pointer != NULL )
    {
        mbedtls_fprintf( stderr, "all-bits-zero is not a NULL pointer\r\n" );
        TEST_ASSERT( 1 );
    }

    /*
     * Make sure we have a snprintf that correctly zero-terminates
     */
    if( run_test_snprintf() != 0 )
    {
        mbedtls_fprintf( stderr, "the snprintf implementation is broken\r\n" );
        TEST_ASSERT( 0 );
    }

    /* Now begin to execute the tests */
    while( *test_suite_data != '\0' )
    {
        if( unmet_dep_count > 0 )
        {
            mbedtls_printf("FATAL: Dep count larger than zero at start of loop\r\n");
            mbedtls_exit( MBEDTLS_EXIT_FAILURE );
        }
        unmet_dep_count = 0;

        if( ( ret = get_line( &test_suite_data, buf, sizeof(buf) ) ) != 0 )
            break;
        mbedtls_fprintf( stdout, "%s%.66s", test_errors ? "\r\n" : "", buf );
        mbedtls_fprintf( stdout, " " );
        for( i = strlen( buf ) + 1; i < 67; i++ )
            mbedtls_fprintf( stdout, "." );
        mbedtls_fprintf( stdout, " " );
        fflush( stdout );

        total_tests++;

        if( ( ret = get_line( &test_suite_data, buf, sizeof(buf) ) ) != 0 )
            break;
        cnt = parse_arguments( buf, strlen(buf), params );

        if( strcmp( params[0], "depends_on" ) == 0 )
        {
            for( i = 1; i < cnt; i++ )
            {
                if( dep_check( params[i] ) != DEPENDENCY_SUPPORTED )
                {
                    unmet_dependencies[ unmet_dep_count ] = strdup(params[i]);
                    if(  unmet_dependencies[ unmet_dep_count ] == NULL )
                    {
                        mbedtls_printf("FATAL: Out of memory\r\n");
                        mbedtls_exit( MBEDTLS_EXIT_FAILURE );
                    }
                    unmet_dep_count++;
                }
            }

            if( ( ret = get_line( &test_suite_data, buf, sizeof(buf) ) ) != 0 )
                break;
            cnt = parse_arguments( buf, strlen(buf), params );
        }

        // If there are no unmet dependencies execute the test
        if( unmet_dep_count == 0 )
        {
            test_errors = 0;
            ret = dispatch_test( cnt, params );
        }

        if( unmet_dep_count > 0 || ret == DISPATCH_UNSUPPORTED_SUITE )
        {
            total_skipped++;
            mbedtls_fprintf( stdout, "----\r\n" );

            if( ret == DISPATCH_UNSUPPORTED_SUITE )
            {
                mbedtls_fprintf( stdout, "   Test Suite not enabled" );
            }

            if( unmet_dep_count > 0 )
            {
                mbedtls_fprintf( stdout, "   Unmet dependencies: " );
                for( i = 0; i < unmet_dep_count; i++ )
                {
                    mbedtls_fprintf(stdout, "%s  ",
                                    unmet_dependencies[i]);
                    free(unmet_dependencies[i]);
                }
                mbedtls_fprintf( stdout, "\r\n" );
            }
            fflush( stdout );

            unmet_dep_count = 0;
        }
        else if( ret == DISPATCH_TEST_SUCCESS && test_errors == 0 )
        {
            mbedtls_fprintf( stdout, "PASS\r\n" );
            fflush( stdout );
        }
        else if( ret == DISPATCH_INVALID_TEST_DATA )
        {
            mbedtls_fprintf( stderr, "FAILED: FATAL PARSE ERROR\r\n" );
            mbedtls_exit( 2 );
        }
        else
            total_errors++;

        if( ( ret = get_line( &test_suite_data, buf, sizeof(buf) ) ) != 0 )
            break;
        if( strlen(buf) != 0 )
        {
            mbedtls_fprintf( stderr, "Should be empty %d\r\n",
                             (int) strlen(buf) );
            TEST_ASSERT( 1 );
        }
    }

    /* In case we encounter early end of file */
    for( i = 0; i < unmet_dep_count; i++ )
        free( unmet_dependencies[i] );

    mbedtls_fprintf( stdout, "\r\n----------------------------------------------------------------------------\r\n\r\n");
    if( total_errors == 0 )
        mbedtls_fprintf( stdout, "PASSED" );
    else
        mbedtls_fprintf( stdout, "FAILED" );

    mbedtls_fprintf( stdout, " (%d / %d tests (%d skipped))\r\n",
             total_tests - total_errors, total_tests, total_skipped );

    TEST_ASSERT( total_errors == 0 );
}

Case cases[] = {
    Case("Machine generated testcase for TESTCASE_FILENAME", test_case)
};

utest::v1::status_t test_setup(const size_t number_of_cases) {
    GREENTEA_SETUP(60, "default_auto");
    return verbose_test_setup_handler(number_of_cases);
}

Specification specification(test_setup, cases);

int main() {
    return !Harness::run(specification);
}
