/*
 *  The AEGIS block cipher was designed by Hongjun Wu and Bart Preneel.
 *
 *  https://eprint.iacr.org/2013/695.pdf
 *
 *
 *
 *  The AES block cipher was designed by Vincent Rijmen and Joan Daemen.
 *
 *  http://csrc.nist.gov/encryption/aes/rijndael/Rijndael.pdf
 *  http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf
 *
 *
 *
 *  Original code by CEASAR competition.
 *
 *  https://competitions.cr.yp.to/caesar.html
 *
 *
 *  Modifications copyright (C) 2018 Benjamin Weigl <r0ot@online.de>
 */

#if !defined(MBEDTLS_CONFIG_FILE)
#include "mbedtls/config.h"
#else
#include MBEDTLS_CONFIG_FILE
#endif

#if defined(MBEDTLS_AEGIS_C)

#include "mbedtls/aegis.h"

#include <string.h>

#if defined(MBEDTLS_SELF_TEST) && defined(MBEDTLS_AES_C)
#if defined(MBEDTLS_PLATFORM_C)
#include "mbedtls/platform.h"
#else
#include <stdio.h>
#define mbedtls_printf printf
#endif /* MBEDTLS_PLATFORM_C */
#endif /* MBEDTLS_SELF_TEST && MBEDTLS_AES_C */

/* AES software implementation */

void AESROUND(unsigned char *out, unsigned char  *in, unsigned char *rk);
void mbedtls_aegis_tag_generation(mbedtls_aegis_context *ctx, unsigned char *tag, unsigned long tag_len);
void mbedtls_aegis_crypto_auth_step(mbedtls_aegis_context *ctx, int mode, const unsigned char *input, unsigned char *output);
void mbedtls_aegis_setup( mbedtls_aegis_context *ctx, const unsigned char *iv );

#if !defined(MBEDTLS_AESNI_C)
const unsigned char TE0[1024] = {
0xc6,0x63,0x63,0xa5,  0xf8,0x7c,0x7c,0x84,  0xee,0x77,0x77,0x99,  0xf6,0x7b,0x7b,0x8d,
0xff,0xf2,0xf2,0xd,   0xd6,0x6b,0x6b,0xbd,  0xde,0x6f,0x6f,0xb1,  0x91,0xc5,0xc5,0x54,
0x60,0x30,0x30,0x50,  0x2,0x1,0x1,0x3,      0xce,0x67,0x67,0xa9,  0x56,0x2b,0x2b,0x7d,
0xe7,0xfe,0xfe,0x19,  0xb5,0xd7,0xd7,0x62,  0x4d,0xab,0xab,0xe6,  0xec,0x76,0x76,0x9a,
0x8f,0xca,0xca,0x45,  0x1f,0x82,0x82,0x9d,  0x89,0xc9,0xc9,0x40,  0xfa,0x7d,0x7d,0x87,
0xef,0xfa,0xfa,0x15,  0xb2,0x59,0x59,0xeb,  0x8e,0x47,0x47,0xc9,  0xfb,0xf0,0xf0,0xb,
0x41,0xad,0xad,0xec,  0xb3,0xd4,0xd4,0x67,  0x5f,0xa2,0xa2,0xfd,  0x45,0xaf,0xaf,0xea,
0x23,0x9c,0x9c,0xbf,  0x53,0xa4,0xa4,0xf7,  0xe4,0x72,0x72,0x96,  0x9b,0xc0,0xc0,0x5b,
0x75,0xb7,0xb7,0xc2,  0xe1,0xfd,0xfd,0x1c,  0x3d,0x93,0x93,0xae,  0x4c,0x26,0x26,0x6a,
0x6c,0x36,0x36,0x5a,  0x7e,0x3f,0x3f,0x41,  0xf5,0xf7,0xf7,0x2,   0x83,0xcc,0xcc,0x4f,
0x68,0x34,0x34,0x5c,  0x51,0xa5,0xa5,0xf4,  0xd1,0xe5,0xe5,0x34,  0xf9,0xf1,0xf1,0x8,
0xe2,0x71,0x71,0x93,  0xab,0xd8,0xd8,0x73,  0x62,0x31,0x31,0x53,  0x2a,0x15,0x15,0x3f,
0x8,0x4,0x4,0xc,      0x95,0xc7,0xc7,0x52,  0x46,0x23,0x23,0x65,  0x9d,0xc3,0xc3,0x5e,
0x30,0x18,0x18,0x28,  0x37,0x96,0x96,0xa1,  0xa,0x5,0x5,0xf,      0x2f,0x9a,0x9a,0xb5,
0xe,0x7,0x7,0x9,      0x24,0x12,0x12,0x36,  0x1b,0x80,0x80,0x9b,  0xdf,0xe2,0xe2,0x3d,
0xcd,0xeb,0xeb,0x26,  0x4e,0x27,0x27,0x69,  0x7f,0xb2,0xb2,0xcd,  0xea,0x75,0x75,0x9f,
0x12,0x9,0x9,0x1b,    0x1d,0x83,0x83,0x9e,  0x58,0x2c,0x2c,0x74,  0x34,0x1a,0x1a,0x2e,
0x36,0x1b,0x1b,0x2d,  0xdc,0x6e,0x6e,0xb2,  0xb4,0x5a,0x5a,0xee,  0x5b,0xa0,0xa0,0xfb,
0xa4,0x52,0x52,0xf6,  0x76,0x3b,0x3b,0x4d,  0xb7,0xd6,0xd6,0x61,  0x7d,0xb3,0xb3,0xce,
0x52,0x29,0x29,0x7b,  0xdd,0xe3,0xe3,0x3e,  0x5e,0x2f,0x2f,0x71,  0x13,0x84,0x84,0x97,
0xa6,0x53,0x53,0xf5,  0xb9,0xd1,0xd1,0x68,  0x0,0x0,0x0,0x0,      0xc1,0xed,0xed,0x2c,
0x40,0x20,0x20,0x60,  0xe3,0xfc,0xfc,0x1f,  0x79,0xb1,0xb1,0xc8,  0xb6,0x5b,0x5b,0xed,
0xd4,0x6a,0x6a,0xbe,  0x8d,0xcb,0xcb,0x46,  0x67,0xbe,0xbe,0xd9,  0x72,0x39,0x39,0x4b,
0x94,0x4a,0x4a,0xde,  0x98,0x4c,0x4c,0xd4,  0xb0,0x58,0x58,0xe8,  0x85,0xcf,0xcf,0x4a,
0xbb,0xd0,0xd0,0x6b,  0xc5,0xef,0xef,0x2a,  0x4f,0xaa,0xaa,0xe5,  0xed,0xfb,0xfb,0x16,
0x86,0x43,0x43,0xc5,  0x9a,0x4d,0x4d,0xd7,  0x66,0x33,0x33,0x55,  0x11,0x85,0x85,0x94,
0x8a,0x45,0x45,0xcf,  0xe9,0xf9,0xf9,0x10,  0x4,0x2,0x2,0x6,      0xfe,0x7f,0x7f,0x81,
0xa0,0x50,0x50,0xf0,  0x78,0x3c,0x3c,0x44,  0x25,0x9f,0x9f,0xba,  0x4b,0xa8,0xa8,0xe3,
0xa2,0x51,0x51,0xf3,  0x5d,0xa3,0xa3,0xfe,  0x80,0x40,0x40,0xc0,  0x5,0x8f,0x8f,0x8a,
0x3f,0x92,0x92,0xad,  0x21,0x9d,0x9d,0xbc,  0x70,0x38,0x38,0x48,  0xf1,0xf5,0xf5,0x4,
0x63,0xbc,0xbc,0xdf,  0x77,0xb6,0xb6,0xc1,  0xaf,0xda,0xda,0x75,  0x42,0x21,0x21,0x63,
0x20,0x10,0x10,0x30,  0xe5,0xff,0xff,0x1a,  0xfd,0xf3,0xf3,0xe,   0xbf,0xd2,0xd2,0x6d,
0x81,0xcd,0xcd,0x4c,  0x18,0xc,0xc,0x14,    0x26,0x13,0x13,0x35,  0xc3,0xec,0xec,0x2f,
0xbe,0x5f,0x5f,0xe1,  0x35,0x97,0x97,0xa2,  0x88,0x44,0x44,0xcc,  0x2e,0x17,0x17,0x39,
0x93,0xc4,0xc4,0x57,  0x55,0xa7,0xa7,0xf2,  0xfc,0x7e,0x7e,0x82,  0x7a,0x3d,0x3d,0x47,
0xc8,0x64,0x64,0xac,  0xba,0x5d,0x5d,0xe7,  0x32,0x19,0x19,0x2b,  0xe6,0x73,0x73,0x95,
0xc0,0x60,0x60,0xa0,  0x19,0x81,0x81,0x98,  0x9e,0x4f,0x4f,0xd1,  0xa3,0xdc,0xdc,0x7f,
0x44,0x22,0x22,0x66,  0x54,0x2a,0x2a,0x7e,  0x3b,0x90,0x90,0xab,  0xb,0x88,0x88,0x83,
0x8c,0x46,0x46,0xca,  0xc7,0xee,0xee,0x29,  0x6b,0xb8,0xb8,0xd3,  0x28,0x14,0x14,0x3c,
0xa7,0xde,0xde,0x79,  0xbc,0x5e,0x5e,0xe2,  0x16,0xb,0xb,0x1d,    0xad,0xdb,0xdb,0x76,
0xdb,0xe0,0xe0,0x3b,  0x64,0x32,0x32,0x56,  0x74,0x3a,0x3a,0x4e,  0x14,0xa,0xa,0x1e,
0x92,0x49,0x49,0xdb,  0xc,0x6,0x6,0xa,      0x48,0x24,0x24,0x6c,  0xb8,0x5c,0x5c,0xe4,
0x9f,0xc2,0xc2,0x5d,  0xbd,0xd3,0xd3,0x6e,  0x43,0xac,0xac,0xef,  0xc4,0x62,0x62,0xa6,
0x39,0x91,0x91,0xa8,  0x31,0x95,0x95,0xa4,  0xd3,0xe4,0xe4,0x37,  0xf2,0x79,0x79,0x8b,
0xd5,0xe7,0xe7,0x32,  0x8b,0xc8,0xc8,0x43,  0x6e,0x37,0x37,0x59,  0xda,0x6d,0x6d,0xb7,
0x1,0x8d,0x8d,0x8c,   0xb1,0xd5,0xd5,0x64,  0x9c,0x4e,0x4e,0xd2,  0x49,0xa9,0xa9,0xe0,
0xd8,0x6c,0x6c,0xb4,  0xac,0x56,0x56,0xfa,  0xf3,0xf4,0xf4,0x7,   0xcf,0xea,0xea,0x25,
0xca,0x65,0x65,0xaf,  0xf4,0x7a,0x7a,0x8e,  0x47,0xae,0xae,0xe9,  0x10,0x8,0x8,0x18,
0x6f,0xba,0xba,0xd5,  0xf0,0x78,0x78,0x88,  0x4a,0x25,0x25,0x6f,  0x5c,0x2e,0x2e,0x72,
0x38,0x1c,0x1c,0x24,  0x57,0xa6,0xa6,0xf1,  0x73,0xb4,0xb4,0xc7,  0x97,0xc6,0xc6,0x51,
0xcb,0xe8,0xe8,0x23,  0xa1,0xdd,0xdd,0x7c,  0xe8,0x74,0x74,0x9c,  0x3e,0x1f,0x1f,0x21,
0x96,0x4b,0x4b,0xdd,  0x61,0xbd,0xbd,0xdc,  0xd,0x8b,0x8b,0x86,   0xf,0x8a,0x8a,0x85,
0xe0,0x70,0x70,0x90,  0x7c,0x3e,0x3e,0x42,  0x71,0xb5,0xb5,0xc4,  0xcc,0x66,0x66,0xaa,
0x90,0x48,0x48,0xd8,  0x6,0x3,0x3,0x5,      0xf7,0xf6,0xf6,0x1,   0x1c,0xe,0xe,0x12,
0xc2,0x61,0x61,0xa3,  0x6a,0x35,0x35,0x5f,  0xae,0x57,0x57,0xf9,  0x69,0xb9,0xb9,0xd0,
0x17,0x86,0x86,0x91,  0x99,0xc1,0xc1,0x58,  0x3a,0x1d,0x1d,0x27,  0x27,0x9e,0x9e,0xb9,
0xd9,0xe1,0xe1,0x38,  0xeb,0xf8,0xf8,0x13,  0x2b,0x98,0x98,0xb3,  0x22,0x11,0x11,0x33,
0xd2,0x69,0x69,0xbb,  0xa9,0xd9,0xd9,0x70,  0x7,0x8e,0x8e,0x89,   0x33,0x94,0x94,0xa7,
0x2d,0x9b,0x9b,0xb6,  0x3c,0x1e,0x1e,0x22,  0x15,0x87,0x87,0x92,  0xc9,0xe9,0xe9,0x20,
0x87,0xce,0xce,0x49,  0xaa,0x55,0x55,0xff,  0x50,0x28,0x28,0x78,  0xa5,0xdf,0xdf,0x7a,
0x3,0x8c,0x8c,0x8f,   0x59,0xa1,0xa1,0xf8,  0x9,0x89,0x89,0x80,   0x1a,0xd,0xd,0x17,
0x65,0xbf,0xbf,0xda,  0xd7,0xe6,0xe6,0x31,  0x84,0x42,0x42,0xc6,  0xd0,0x68,0x68,0xb8,
0x82,0x41,0x41,0xc3,  0x29,0x99,0x99,0xb0,  0x5a,0x2d,0x2d,0x77,  0x1e,0xf,0xf,0x11,
0x7b,0xb0,0xb0,0xcb,  0xa8,0x54,0x54,0xfc,  0x6d,0xbb,0xbb,0xd6,  0x2c,0x16,0x16,0x3a};

const unsigned char TE1[1024] = {
0xa5,0xc6,0x63,0x63,  0x84,0xf8,0x7c,0x7c,  0x99,0xee,0x77,0x77,  0x8d,0xf6,0x7b,0x7b,
0xd,0xff,0xf2,0xf2,   0xbd,0xd6,0x6b,0x6b,  0xb1,0xde,0x6f,0x6f,  0x54,0x91,0xc5,0xc5,
0x50,0x60,0x30,0x30,  0x3,0x2,0x1,0x1,      0xa9,0xce,0x67,0x67,  0x7d,0x56,0x2b,0x2b,
0x19,0xe7,0xfe,0xfe,  0x62,0xb5,0xd7,0xd7,  0xe6,0x4d,0xab,0xab,  0x9a,0xec,0x76,0x76,
0x45,0x8f,0xca,0xca,  0x9d,0x1f,0x82,0x82,  0x40,0x89,0xc9,0xc9,  0x87,0xfa,0x7d,0x7d,
0x15,0xef,0xfa,0xfa,  0xeb,0xb2,0x59,0x59,  0xc9,0x8e,0x47,0x47,  0xb,0xfb,0xf0,0xf0,
0xec,0x41,0xad,0xad,  0x67,0xb3,0xd4,0xd4,  0xfd,0x5f,0xa2,0xa2,  0xea,0x45,0xaf,0xaf,
0xbf,0x23,0x9c,0x9c,  0xf7,0x53,0xa4,0xa4,  0x96,0xe4,0x72,0x72,  0x5b,0x9b,0xc0,0xc0,
0xc2,0x75,0xb7,0xb7,  0x1c,0xe1,0xfd,0xfd,  0xae,0x3d,0x93,0x93,  0x6a,0x4c,0x26,0x26,
0x5a,0x6c,0x36,0x36,  0x41,0x7e,0x3f,0x3f,  0x2,0xf5,0xf7,0xf7,   0x4f,0x83,0xcc,0xcc,
0x5c,0x68,0x34,0x34,  0xf4,0x51,0xa5,0xa5,  0x34,0xd1,0xe5,0xe5,  0x8,0xf9,0xf1,0xf1,
0x93,0xe2,0x71,0x71,  0x73,0xab,0xd8,0xd8,  0x53,0x62,0x31,0x31,  0x3f,0x2a,0x15,0x15,
0xc,0x8,0x4,0x4,      0x52,0x95,0xc7,0xc7,  0x65,0x46,0x23,0x23,  0x5e,0x9d,0xc3,0xc3,
0x28,0x30,0x18,0x18,  0xa1,0x37,0x96,0x96,  0xf,0xa,0x5,0x5,      0xb5,0x2f,0x9a,0x9a,
0x9,0xe,0x7,0x7,      0x36,0x24,0x12,0x12,  0x9b,0x1b,0x80,0x80,  0x3d,0xdf,0xe2,0xe2,
0x26,0xcd,0xeb,0xeb,  0x69,0x4e,0x27,0x27,  0xcd,0x7f,0xb2,0xb2,  0x9f,0xea,0x75,0x75,
0x1b,0x12,0x9,0x9,    0x9e,0x1d,0x83,0x83,  0x74,0x58,0x2c,0x2c,  0x2e,0x34,0x1a,0x1a,
0x2d,0x36,0x1b,0x1b,  0xb2,0xdc,0x6e,0x6e,  0xee,0xb4,0x5a,0x5a,  0xfb,0x5b,0xa0,0xa0,
0xf6,0xa4,0x52,0x52,  0x4d,0x76,0x3b,0x3b,  0x61,0xb7,0xd6,0xd6,  0xce,0x7d,0xb3,0xb3,
0x7b,0x52,0x29,0x29,  0x3e,0xdd,0xe3,0xe3,  0x71,0x5e,0x2f,0x2f,  0x97,0x13,0x84,0x84,
0xf5,0xa6,0x53,0x53,  0x68,0xb9,0xd1,0xd1,  0x0,0x0,0x0,0x0,      0x2c,0xc1,0xed,0xed,
0x60,0x40,0x20,0x20,  0x1f,0xe3,0xfc,0xfc,  0xc8,0x79,0xb1,0xb1,  0xed,0xb6,0x5b,0x5b,
0xbe,0xd4,0x6a,0x6a,  0x46,0x8d,0xcb,0xcb,  0xd9,0x67,0xbe,0xbe,  0x4b,0x72,0x39,0x39,
0xde,0x94,0x4a,0x4a,  0xd4,0x98,0x4c,0x4c,  0xe8,0xb0,0x58,0x58,  0x4a,0x85,0xcf,0xcf,
0x6b,0xbb,0xd0,0xd0,  0x2a,0xc5,0xef,0xef,  0xe5,0x4f,0xaa,0xaa,  0x16,0xed,0xfb,0xfb,
0xc5,0x86,0x43,0x43,  0xd7,0x9a,0x4d,0x4d,  0x55,0x66,0x33,0x33,  0x94,0x11,0x85,0x85,
0xcf,0x8a,0x45,0x45,  0x10,0xe9,0xf9,0xf9,  0x6,0x4,0x2,0x2,      0x81,0xfe,0x7f,0x7f,
0xf0,0xa0,0x50,0x50,  0x44,0x78,0x3c,0x3c,  0xba,0x25,0x9f,0x9f,  0xe3,0x4b,0xa8,0xa8,
0xf3,0xa2,0x51,0x51,  0xfe,0x5d,0xa3,0xa3,  0xc0,0x80,0x40,0x40,  0x8a,0x5,0x8f,0x8f,
0xad,0x3f,0x92,0x92,  0xbc,0x21,0x9d,0x9d,  0x48,0x70,0x38,0x38,  0x4,0xf1,0xf5,0xf5,
0xdf,0x63,0xbc,0xbc,  0xc1,0x77,0xb6,0xb6,  0x75,0xaf,0xda,0xda,  0x63,0x42,0x21,0x21,
0x30,0x20,0x10,0x10,  0x1a,0xe5,0xff,0xff,  0xe,0xfd,0xf3,0xf3,   0x6d,0xbf,0xd2,0xd2,
0x4c,0x81,0xcd,0xcd,  0x14,0x18,0xc,0xc,    0x35,0x26,0x13,0x13,  0x2f,0xc3,0xec,0xec,
0xe1,0xbe,0x5f,0x5f,  0xa2,0x35,0x97,0x97,  0xcc,0x88,0x44,0x44,  0x39,0x2e,0x17,0x17,
0x57,0x93,0xc4,0xc4,  0xf2,0x55,0xa7,0xa7,  0x82,0xfc,0x7e,0x7e,  0x47,0x7a,0x3d,0x3d,
0xac,0xc8,0x64,0x64,  0xe7,0xba,0x5d,0x5d,  0x2b,0x32,0x19,0x19,  0x95,0xe6,0x73,0x73,
0xa0,0xc0,0x60,0x60,  0x98,0x19,0x81,0x81,  0xd1,0x9e,0x4f,0x4f,  0x7f,0xa3,0xdc,0xdc,
0x66,0x44,0x22,0x22,  0x7e,0x54,0x2a,0x2a,  0xab,0x3b,0x90,0x90,  0x83,0xb,0x88,0x88,
0xca,0x8c,0x46,0x46,  0x29,0xc7,0xee,0xee,  0xd3,0x6b,0xb8,0xb8,  0x3c,0x28,0x14,0x14,
0x79,0xa7,0xde,0xde,  0xe2,0xbc,0x5e,0x5e,  0x1d,0x16,0xb,0xb,    0x76,0xad,0xdb,0xdb,
0x3b,0xdb,0xe0,0xe0,  0x56,0x64,0x32,0x32,  0x4e,0x74,0x3a,0x3a,  0x1e,0x14,0xa,0xa,
0xdb,0x92,0x49,0x49,  0xa,0xc,0x6,0x6,      0x6c,0x48,0x24,0x24,  0xe4,0xb8,0x5c,0x5c,
0x5d,0x9f,0xc2,0xc2,  0x6e,0xbd,0xd3,0xd3,  0xef,0x43,0xac,0xac,  0xa6,0xc4,0x62,0x62,
0xa8,0x39,0x91,0x91,  0xa4,0x31,0x95,0x95,  0x37,0xd3,0xe4,0xe4,  0x8b,0xf2,0x79,0x79,
0x32,0xd5,0xe7,0xe7,  0x43,0x8b,0xc8,0xc8,  0x59,0x6e,0x37,0x37,  0xb7,0xda,0x6d,0x6d,
0x8c,0x1,0x8d,0x8d,   0x64,0xb1,0xd5,0xd5,  0xd2,0x9c,0x4e,0x4e,  0xe0,0x49,0xa9,0xa9,
0xb4,0xd8,0x6c,0x6c,  0xfa,0xac,0x56,0x56,  0x7,0xf3,0xf4,0xf4,   0x25,0xcf,0xea,0xea,
0xaf,0xca,0x65,0x65,  0x8e,0xf4,0x7a,0x7a,  0xe9,0x47,0xae,0xae,  0x18,0x10,0x8,0x8,
0xd5,0x6f,0xba,0xba,  0x88,0xf0,0x78,0x78,  0x6f,0x4a,0x25,0x25,  0x72,0x5c,0x2e,0x2e,
0x24,0x38,0x1c,0x1c,  0xf1,0x57,0xa6,0xa6,  0xc7,0x73,0xb4,0xb4,  0x51,0x97,0xc6,0xc6,
0x23,0xcb,0xe8,0xe8,  0x7c,0xa1,0xdd,0xdd,  0x9c,0xe8,0x74,0x74,  0x21,0x3e,0x1f,0x1f,
0xdd,0x96,0x4b,0x4b,  0xdc,0x61,0xbd,0xbd,  0x86,0xd,0x8b,0x8b,   0x85,0xf,0x8a,0x8a,
0x90,0xe0,0x70,0x70,  0x42,0x7c,0x3e,0x3e,  0xc4,0x71,0xb5,0xb5,  0xaa,0xcc,0x66,0x66,
0xd8,0x90,0x48,0x48,  0x5,0x6,0x3,0x3,      0x1,0xf7,0xf6,0xf6,   0x12,0x1c,0xe,0xe,
0xa3,0xc2,0x61,0x61,  0x5f,0x6a,0x35,0x35,  0xf9,0xae,0x57,0x57,  0xd0,0x69,0xb9,0xb9,
0x91,0x17,0x86,0x86,  0x58,0x99,0xc1,0xc1,  0x27,0x3a,0x1d,0x1d,  0xb9,0x27,0x9e,0x9e,
0x38,0xd9,0xe1,0xe1,  0x13,0xeb,0xf8,0xf8,  0xb3,0x2b,0x98,0x98,  0x33,0x22,0x11,0x11,
0xbb,0xd2,0x69,0x69,  0x70,0xa9,0xd9,0xd9,  0x89,0x7,0x8e,0x8e,   0xa7,0x33,0x94,0x94,
0xb6,0x2d,0x9b,0x9b,  0x22,0x3c,0x1e,0x1e,  0x92,0x15,0x87,0x87,  0x20,0xc9,0xe9,0xe9,
0x49,0x87,0xce,0xce,  0xff,0xaa,0x55,0x55,  0x78,0x50,0x28,0x28,  0x7a,0xa5,0xdf,0xdf,
0x8f,0x3,0x8c,0x8c,   0xf8,0x59,0xa1,0xa1,  0x80,0x9,0x89,0x89,   0x17,0x1a,0xd,0xd,
0xda,0x65,0xbf,0xbf,  0x31,0xd7,0xe6,0xe6,  0xc6,0x84,0x42,0x42,  0xb8,0xd0,0x68,0x68,
0xc3,0x82,0x41,0x41,  0xb0,0x29,0x99,0x99,  0x77,0x5a,0x2d,0x2d,  0x11,0x1e,0xf,0xf,
0xcb,0x7b,0xb0,0xb0,  0xfc,0xa8,0x54,0x54,  0xd6,0x6d,0xbb,0xbb,  0x3a,0x2c,0x16,0x16};

const unsigned char TE2[1024] = {
0x63,0xa5,0xc6,0x63,  0x7c,0x84,0xf8,0x7c,  0x77,0x99,0xee,0x77,  0x7b,0x8d,0xf6,0x7b,
0xf2,0xd,0xff,0xf2,   0x6b,0xbd,0xd6,0x6b,  0x6f,0xb1,0xde,0x6f,  0xc5,0x54,0x91,0xc5,
0x30,0x50,0x60,0x30,  0x1,0x3,0x2,0x1,      0x67,0xa9,0xce,0x67,  0x2b,0x7d,0x56,0x2b,
0xfe,0x19,0xe7,0xfe,  0xd7,0x62,0xb5,0xd7,  0xab,0xe6,0x4d,0xab,  0x76,0x9a,0xec,0x76,
0xca,0x45,0x8f,0xca,  0x82,0x9d,0x1f,0x82,  0xc9,0x40,0x89,0xc9,  0x7d,0x87,0xfa,0x7d,
0xfa,0x15,0xef,0xfa,  0x59,0xeb,0xb2,0x59,  0x47,0xc9,0x8e,0x47,  0xf0,0xb,0xfb,0xf0,
0xad,0xec,0x41,0xad,  0xd4,0x67,0xb3,0xd4,  0xa2,0xfd,0x5f,0xa2,  0xaf,0xea,0x45,0xaf,
0x9c,0xbf,0x23,0x9c,  0xa4,0xf7,0x53,0xa4,  0x72,0x96,0xe4,0x72,  0xc0,0x5b,0x9b,0xc0,
0xb7,0xc2,0x75,0xb7,  0xfd,0x1c,0xe1,0xfd,  0x93,0xae,0x3d,0x93,  0x26,0x6a,0x4c,0x26,
0x36,0x5a,0x6c,0x36,  0x3f,0x41,0x7e,0x3f,  0xf7,0x2,0xf5,0xf7,   0xcc,0x4f,0x83,0xcc,
0x34,0x5c,0x68,0x34,  0xa5,0xf4,0x51,0xa5,  0xe5,0x34,0xd1,0xe5,  0xf1,0x8,0xf9,0xf1,
0x71,0x93,0xe2,0x71,  0xd8,0x73,0xab,0xd8,  0x31,0x53,0x62,0x31,  0x15,0x3f,0x2a,0x15,
0x4,0xc,0x8,0x4,      0xc7,0x52,0x95,0xc7,  0x23,0x65,0x46,0x23,  0xc3,0x5e,0x9d,0xc3,
0x18,0x28,0x30,0x18,  0x96,0xa1,0x37,0x96,  0x5,0xf,0xa,0x5,      0x9a,0xb5,0x2f,0x9a,
0x7,0x9,0xe,0x7,      0x12,0x36,0x24,0x12,  0x80,0x9b,0x1b,0x80,  0xe2,0x3d,0xdf,0xe2,
0xeb,0x26,0xcd,0xeb,  0x27,0x69,0x4e,0x27,  0xb2,0xcd,0x7f,0xb2,  0x75,0x9f,0xea,0x75,
0x9,0x1b,0x12,0x9,    0x83,0x9e,0x1d,0x83,  0x2c,0x74,0x58,0x2c,  0x1a,0x2e,0x34,0x1a,
0x1b,0x2d,0x36,0x1b,  0x6e,0xb2,0xdc,0x6e,  0x5a,0xee,0xb4,0x5a,  0xa0,0xfb,0x5b,0xa0,
0x52,0xf6,0xa4,0x52,  0x3b,0x4d,0x76,0x3b,  0xd6,0x61,0xb7,0xd6,  0xb3,0xce,0x7d,0xb3,
0x29,0x7b,0x52,0x29,  0xe3,0x3e,0xdd,0xe3,  0x2f,0x71,0x5e,0x2f,  0x84,0x97,0x13,0x84,
0x53,0xf5,0xa6,0x53,  0xd1,0x68,0xb9,0xd1,  0x0,0x0,0x0,0x0,      0xed,0x2c,0xc1,0xed,
0x20,0x60,0x40,0x20,  0xfc,0x1f,0xe3,0xfc,  0xb1,0xc8,0x79,0xb1,  0x5b,0xed,0xb6,0x5b,
0x6a,0xbe,0xd4,0x6a,  0xcb,0x46,0x8d,0xcb,  0xbe,0xd9,0x67,0xbe,  0x39,0x4b,0x72,0x39,
0x4a,0xde,0x94,0x4a,  0x4c,0xd4,0x98,0x4c,  0x58,0xe8,0xb0,0x58,  0xcf,0x4a,0x85,0xcf,
0xd0,0x6b,0xbb,0xd0,  0xef,0x2a,0xc5,0xef,  0xaa,0xe5,0x4f,0xaa,  0xfb,0x16,0xed,0xfb,
0x43,0xc5,0x86,0x43,  0x4d,0xd7,0x9a,0x4d,  0x33,0x55,0x66,0x33,  0x85,0x94,0x11,0x85,
0x45,0xcf,0x8a,0x45,  0xf9,0x10,0xe9,0xf9,  0x2,0x6,0x4,0x2,      0x7f,0x81,0xfe,0x7f,
0x50,0xf0,0xa0,0x50,  0x3c,0x44,0x78,0x3c,  0x9f,0xba,0x25,0x9f,  0xa8,0xe3,0x4b,0xa8,
0x51,0xf3,0xa2,0x51,  0xa3,0xfe,0x5d,0xa3,  0x40,0xc0,0x80,0x40,  0x8f,0x8a,0x5,0x8f,
0x92,0xad,0x3f,0x92,  0x9d,0xbc,0x21,0x9d,  0x38,0x48,0x70,0x38,  0xf5,0x4,0xf1,0xf5,
0xbc,0xdf,0x63,0xbc,  0xb6,0xc1,0x77,0xb6,  0xda,0x75,0xaf,0xda,  0x21,0x63,0x42,0x21,
0x10,0x30,0x20,0x10,  0xff,0x1a,0xe5,0xff,  0xf3,0xe,0xfd,0xf3,   0xd2,0x6d,0xbf,0xd2,
0xcd,0x4c,0x81,0xcd,  0xc,0x14,0x18,0xc,    0x13,0x35,0x26,0x13,  0xec,0x2f,0xc3,0xec,
0x5f,0xe1,0xbe,0x5f,  0x97,0xa2,0x35,0x97,  0x44,0xcc,0x88,0x44,  0x17,0x39,0x2e,0x17,
0xc4,0x57,0x93,0xc4,  0xa7,0xf2,0x55,0xa7,  0x7e,0x82,0xfc,0x7e,  0x3d,0x47,0x7a,0x3d,
0x64,0xac,0xc8,0x64,  0x5d,0xe7,0xba,0x5d,  0x19,0x2b,0x32,0x19,  0x73,0x95,0xe6,0x73,
0x60,0xa0,0xc0,0x60,  0x81,0x98,0x19,0x81,  0x4f,0xd1,0x9e,0x4f,  0xdc,0x7f,0xa3,0xdc,
0x22,0x66,0x44,0x22,  0x2a,0x7e,0x54,0x2a,  0x90,0xab,0x3b,0x90,  0x88,0x83,0xb,0x88,
0x46,0xca,0x8c,0x46,  0xee,0x29,0xc7,0xee,  0xb8,0xd3,0x6b,0xb8,  0x14,0x3c,0x28,0x14,
0xde,0x79,0xa7,0xde,  0x5e,0xe2,0xbc,0x5e,  0xb,0x1d,0x16,0xb,    0xdb,0x76,0xad,0xdb,
0xe0,0x3b,0xdb,0xe0,  0x32,0x56,0x64,0x32,  0x3a,0x4e,0x74,0x3a,  0xa,0x1e,0x14,0xa,
0x49,0xdb,0x92,0x49,  0x6,0xa,0xc,0x6,      0x24,0x6c,0x48,0x24,  0x5c,0xe4,0xb8,0x5c,
0xc2,0x5d,0x9f,0xc2,  0xd3,0x6e,0xbd,0xd3,  0xac,0xef,0x43,0xac,  0x62,0xa6,0xc4,0x62,
0x91,0xa8,0x39,0x91,  0x95,0xa4,0x31,0x95,  0xe4,0x37,0xd3,0xe4,  0x79,0x8b,0xf2,0x79,
0xe7,0x32,0xd5,0xe7,  0xc8,0x43,0x8b,0xc8,  0x37,0x59,0x6e,0x37,  0x6d,0xb7,0xda,0x6d,
0x8d,0x8c,0x1,0x8d,   0xd5,0x64,0xb1,0xd5,  0x4e,0xd2,0x9c,0x4e,  0xa9,0xe0,0x49,0xa9,
0x6c,0xb4,0xd8,0x6c,  0x56,0xfa,0xac,0x56,  0xf4,0x7,0xf3,0xf4,   0xea,0x25,0xcf,0xea,
0x65,0xaf,0xca,0x65,  0x7a,0x8e,0xf4,0x7a,  0xae,0xe9,0x47,0xae,  0x8,0x18,0x10,0x8,
0xba,0xd5,0x6f,0xba,  0x78,0x88,0xf0,0x78,  0x25,0x6f,0x4a,0x25,  0x2e,0x72,0x5c,0x2e,
0x1c,0x24,0x38,0x1c,  0xa6,0xf1,0x57,0xa6,  0xb4,0xc7,0x73,0xb4,  0xc6,0x51,0x97,0xc6,
0xe8,0x23,0xcb,0xe8,  0xdd,0x7c,0xa1,0xdd,  0x74,0x9c,0xe8,0x74,  0x1f,0x21,0x3e,0x1f,
0x4b,0xdd,0x96,0x4b,  0xbd,0xdc,0x61,0xbd,  0x8b,0x86,0xd,0x8b,   0x8a,0x85,0xf,0x8a,
0x70,0x90,0xe0,0x70,  0x3e,0x42,0x7c,0x3e,  0xb5,0xc4,0x71,0xb5,  0x66,0xaa,0xcc,0x66,
0x48,0xd8,0x90,0x48,  0x3,0x5,0x6,0x3,      0xf6,0x1,0xf7,0xf6,   0xe,0x12,0x1c,0xe,
0x61,0xa3,0xc2,0x61,  0x35,0x5f,0x6a,0x35,  0x57,0xf9,0xae,0x57,  0xb9,0xd0,0x69,0xb9,
0x86,0x91,0x17,0x86,  0xc1,0x58,0x99,0xc1,  0x1d,0x27,0x3a,0x1d,  0x9e,0xb9,0x27,0x9e,
0xe1,0x38,0xd9,0xe1,  0xf8,0x13,0xeb,0xf8,  0x98,0xb3,0x2b,0x98,  0x11,0x33,0x22,0x11,
0x69,0xbb,0xd2,0x69,  0xd9,0x70,0xa9,0xd9,  0x8e,0x89,0x7,0x8e,   0x94,0xa7,0x33,0x94,
0x9b,0xb6,0x2d,0x9b,  0x1e,0x22,0x3c,0x1e,  0x87,0x92,0x15,0x87,  0xe9,0x20,0xc9,0xe9,
0xce,0x49,0x87,0xce,  0x55,0xff,0xaa,0x55,  0x28,0x78,0x50,0x28,  0xdf,0x7a,0xa5,0xdf,
0x8c,0x8f,0x3,0x8c,   0xa1,0xf8,0x59,0xa1,  0x89,0x80,0x9,0x89,   0xd,0x17,0x1a,0xd,
0xbf,0xda,0x65,0xbf,  0xe6,0x31,0xd7,0xe6,  0x42,0xc6,0x84,0x42,  0x68,0xb8,0xd0,0x68,
0x41,0xc3,0x82,0x41,  0x99,0xb0,0x29,0x99,  0x2d,0x77,0x5a,0x2d,  0xf,0x11,0x1e,0xf,
0xb0,0xcb,0x7b,0xb0,  0x54,0xfc,0xa8,0x54,  0xbb,0xd6,0x6d,0xbb,  0x16,0x3a,0x2c,0x16};

const unsigned char TE3[1024] = {
0x63,0x63,0xa5,0xc6,  0x7c,0x7c,0x84,0xf8,  0x77,0x77,0x99,0xee,  0x7b,0x7b,0x8d,0xf6,
0xf2,0xf2,0xd,0xff,   0x6b,0x6b,0xbd,0xd6,  0x6f,0x6f,0xb1,0xde,  0xc5,0xc5,0x54,0x91,
0x30,0x30,0x50,0x60,  0x1,0x1,0x3,0x2,      0x67,0x67,0xa9,0xce,  0x2b,0x2b,0x7d,0x56,
0xfe,0xfe,0x19,0xe7,  0xd7,0xd7,0x62,0xb5,  0xab,0xab,0xe6,0x4d,  0x76,0x76,0x9a,0xec,
0xca,0xca,0x45,0x8f,  0x82,0x82,0x9d,0x1f,  0xc9,0xc9,0x40,0x89,  0x7d,0x7d,0x87,0xfa,
0xfa,0xfa,0x15,0xef,  0x59,0x59,0xeb,0xb2,  0x47,0x47,0xc9,0x8e,  0xf0,0xf0,0xb,0xfb,
0xad,0xad,0xec,0x41,  0xd4,0xd4,0x67,0xb3,  0xa2,0xa2,0xfd,0x5f,  0xaf,0xaf,0xea,0x45,
0x9c,0x9c,0xbf,0x23,  0xa4,0xa4,0xf7,0x53,  0x72,0x72,0x96,0xe4,  0xc0,0xc0,0x5b,0x9b,
0xb7,0xb7,0xc2,0x75,  0xfd,0xfd,0x1c,0xe1,  0x93,0x93,0xae,0x3d,  0x26,0x26,0x6a,0x4c,
0x36,0x36,0x5a,0x6c,  0x3f,0x3f,0x41,0x7e,  0xf7,0xf7,0x2,0xf5,   0xcc,0xcc,0x4f,0x83,
0x34,0x34,0x5c,0x68,  0xa5,0xa5,0xf4,0x51,  0xe5,0xe5,0x34,0xd1,  0xf1,0xf1,0x8,0xf9,
0x71,0x71,0x93,0xe2,  0xd8,0xd8,0x73,0xab,  0x31,0x31,0x53,0x62,  0x15,0x15,0x3f,0x2a,
0x4,0x4,0xc,0x8,      0xc7,0xc7,0x52,0x95,  0x23,0x23,0x65,0x46,  0xc3,0xc3,0x5e,0x9d,
0x18,0x18,0x28,0x30,  0x96,0x96,0xa1,0x37,  0x5,0x5,0xf,0xa,      0x9a,0x9a,0xb5,0x2f,
0x7,0x7,0x9,0xe,      0x12,0x12,0x36,0x24,  0x80,0x80,0x9b,0x1b,  0xe2,0xe2,0x3d,0xdf,
0xeb,0xeb,0x26,0xcd,  0x27,0x27,0x69,0x4e,  0xb2,0xb2,0xcd,0x7f,  0x75,0x75,0x9f,0xea,
0x9,0x9,0x1b,0x12,    0x83,0x83,0x9e,0x1d,  0x2c,0x2c,0x74,0x58,  0x1a,0x1a,0x2e,0x34,
0x1b,0x1b,0x2d,0x36,  0x6e,0x6e,0xb2,0xdc,  0x5a,0x5a,0xee,0xb4,  0xa0,0xa0,0xfb,0x5b,
0x52,0x52,0xf6,0xa4,  0x3b,0x3b,0x4d,0x76,  0xd6,0xd6,0x61,0xb7,  0xb3,0xb3,0xce,0x7d,
0x29,0x29,0x7b,0x52,  0xe3,0xe3,0x3e,0xdd,  0x2f,0x2f,0x71,0x5e,  0x84,0x84,0x97,0x13,
0x53,0x53,0xf5,0xa6,  0xd1,0xd1,0x68,0xb9,  0x0,0x0,0x0,0x0,      0xed,0xed,0x2c,0xc1,
0x20,0x20,0x60,0x40,  0xfc,0xfc,0x1f,0xe3,  0xb1,0xb1,0xc8,0x79,  0x5b,0x5b,0xed,0xb6,
0x6a,0x6a,0xbe,0xd4,  0xcb,0xcb,0x46,0x8d,  0xbe,0xbe,0xd9,0x67,  0x39,0x39,0x4b,0x72,
0x4a,0x4a,0xde,0x94,  0x4c,0x4c,0xd4,0x98,  0x58,0x58,0xe8,0xb0,  0xcf,0xcf,0x4a,0x85,
0xd0,0xd0,0x6b,0xbb,  0xef,0xef,0x2a,0xc5,  0xaa,0xaa,0xe5,0x4f,  0xfb,0xfb,0x16,0xed,
0x43,0x43,0xc5,0x86,  0x4d,0x4d,0xd7,0x9a,  0x33,0x33,0x55,0x66,  0x85,0x85,0x94,0x11,
0x45,0x45,0xcf,0x8a,  0xf9,0xf9,0x10,0xe9,  0x2,0x2,0x6,0x4,      0x7f,0x7f,0x81,0xfe,
0x50,0x50,0xf0,0xa0,  0x3c,0x3c,0x44,0x78,  0x9f,0x9f,0xba,0x25,  0xa8,0xa8,0xe3,0x4b,
0x51,0x51,0xf3,0xa2,  0xa3,0xa3,0xfe,0x5d,  0x40,0x40,0xc0,0x80,  0x8f,0x8f,0x8a,0x5,
0x92,0x92,0xad,0x3f,  0x9d,0x9d,0xbc,0x21,  0x38,0x38,0x48,0x70,  0xf5,0xf5,0x4,0xf1,
0xbc,0xbc,0xdf,0x63,  0xb6,0xb6,0xc1,0x77,  0xda,0xda,0x75,0xaf,  0x21,0x21,0x63,0x42,
0x10,0x10,0x30,0x20,  0xff,0xff,0x1a,0xe5,  0xf3,0xf3,0xe,0xfd,   0xd2,0xd2,0x6d,0xbf,
0xcd,0xcd,0x4c,0x81,  0xc,0xc,0x14,0x18,    0x13,0x13,0x35,0x26,  0xec,0xec,0x2f,0xc3,
0x5f,0x5f,0xe1,0xbe,  0x97,0x97,0xa2,0x35,  0x44,0x44,0xcc,0x88,  0x17,0x17,0x39,0x2e,
0xc4,0xc4,0x57,0x93,  0xa7,0xa7,0xf2,0x55,  0x7e,0x7e,0x82,0xfc,  0x3d,0x3d,0x47,0x7a,
0x64,0x64,0xac,0xc8,  0x5d,0x5d,0xe7,0xba,  0x19,0x19,0x2b,0x32,  0x73,0x73,0x95,0xe6,
0x60,0x60,0xa0,0xc0,  0x81,0x81,0x98,0x19,  0x4f,0x4f,0xd1,0x9e,  0xdc,0xdc,0x7f,0xa3,
0x22,0x22,0x66,0x44,  0x2a,0x2a,0x7e,0x54,  0x90,0x90,0xab,0x3b,  0x88,0x88,0x83,0xb,
0x46,0x46,0xca,0x8c,  0xee,0xee,0x29,0xc7,  0xb8,0xb8,0xd3,0x6b,  0x14,0x14,0x3c,0x28,
0xde,0xde,0x79,0xa7,  0x5e,0x5e,0xe2,0xbc,  0xb,0xb,0x1d,0x16,    0xdb,0xdb,0x76,0xad,
0xe0,0xe0,0x3b,0xdb,  0x32,0x32,0x56,0x64,  0x3a,0x3a,0x4e,0x74,  0xa,0xa,0x1e,0x14,
0x49,0x49,0xdb,0x92,  0x6,0x6,0xa,0xc,      0x24,0x24,0x6c,0x48,  0x5c,0x5c,0xe4,0xb8,
0xc2,0xc2,0x5d,0x9f,  0xd3,0xd3,0x6e,0xbd,  0xac,0xac,0xef,0x43,  0x62,0x62,0xa6,0xc4,
0x91,0x91,0xa8,0x39,  0x95,0x95,0xa4,0x31,  0xe4,0xe4,0x37,0xd3,  0x79,0x79,0x8b,0xf2,
0xe7,0xe7,0x32,0xd5,  0xc8,0xc8,0x43,0x8b,  0x37,0x37,0x59,0x6e,  0x6d,0x6d,0xb7,0xda,
0x8d,0x8d,0x8c,0x1,   0xd5,0xd5,0x64,0xb1,  0x4e,0x4e,0xd2,0x9c,  0xa9,0xa9,0xe0,0x49,
0x6c,0x6c,0xb4,0xd8,  0x56,0x56,0xfa,0xac,  0xf4,0xf4,0x7,0xf3,   0xea,0xea,0x25,0xcf,
0x65,0x65,0xaf,0xca,  0x7a,0x7a,0x8e,0xf4,  0xae,0xae,0xe9,0x47,  0x8,0x8,0x18,0x10,
0xba,0xba,0xd5,0x6f,  0x78,0x78,0x88,0xf0,  0x25,0x25,0x6f,0x4a,  0x2e,0x2e,0x72,0x5c,
0x1c,0x1c,0x24,0x38,  0xa6,0xa6,0xf1,0x57,  0xb4,0xb4,0xc7,0x73,  0xc6,0xc6,0x51,0x97,
0xe8,0xe8,0x23,0xcb,  0xdd,0xdd,0x7c,0xa1,  0x74,0x74,0x9c,0xe8,  0x1f,0x1f,0x21,0x3e,
0x4b,0x4b,0xdd,0x96,  0xbd,0xbd,0xdc,0x61,  0x8b,0x8b,0x86,0xd,   0x8a,0x8a,0x85,0xf,
0x70,0x70,0x90,0xe0,  0x3e,0x3e,0x42,0x7c,  0xb5,0xb5,0xc4,0x71,  0x66,0x66,0xaa,0xcc,
0x48,0x48,0xd8,0x90,  0x3,0x3,0x5,0x6,      0xf6,0xf6,0x1,0xf7,   0xe,0xe,0x12,0x1c,
0x61,0x61,0xa3,0xc2,  0x35,0x35,0x5f,0x6a,  0x57,0x57,0xf9,0xae,  0xb9,0xb9,0xd0,0x69,
0x86,0x86,0x91,0x17,  0xc1,0xc1,0x58,0x99,  0x1d,0x1d,0x27,0x3a,  0x9e,0x9e,0xb9,0x27,
0xe1,0xe1,0x38,0xd9,  0xf8,0xf8,0x13,0xeb,  0x98,0x98,0xb3,0x2b,  0x11,0x11,0x33,0x22,
0x69,0x69,0xbb,0xd2,  0xd9,0xd9,0x70,0xa9,  0x8e,0x8e,0x89,0x7,   0x94,0x94,0xa7,0x33,
0x9b,0x9b,0xb6,0x2d,  0x1e,0x1e,0x22,0x3c,  0x87,0x87,0x92,0x15,  0xe9,0xe9,0x20,0xc9,
0xce,0xce,0x49,0x87,  0x55,0x55,0xff,0xaa,  0x28,0x28,0x78,0x50,  0xdf,0xdf,0x7a,0xa5,
0x8c,0x8c,0x8f,0x3,   0xa1,0xa1,0xf8,0x59,  0x89,0x89,0x80,0x9,   0xd,0xd,0x17,0x1a,
0xbf,0xbf,0xda,0x65,  0xe6,0xe6,0x31,0xd7,  0x42,0x42,0xc6,0x84,  0x68,0x68,0xb8,0xd0,
0x41,0x41,0xc3,0x82,  0x99,0x99,0xb0,0x29,  0x2d,0x2d,0x77,0x5a,  0xf,0xf,0x11,0x1e,
0xb0,0xb0,0xcb,0x7b,  0x54,0x54,0xfc,0xa8,  0xbb,0xbb,0xd6,0x6d,  0x16,0x16,0x3a,0x2c};

const unsigned char constant[32] = { 0x0, 0x1, 0x01, 0x02, 0x03, 0x05, 0x08, 0x0d,
                                0x15, 0x22, 0x37, 0x59, 0x90, 0xe9, 0x79, 0x62,
                                0xdb, 0x3d, 0x18, 0x55, 0x6d, 0xc2, 0x2f, 0xf1,
                                0x20, 0x11, 0x31, 0x42, 0x73, 0xb5, 0x28, 0xdd };
#endif /* !defined(MBEDTLS_AESNI_C) */

/* Implementation that should never be optimized out by the compiler */
static void mbedtls_zeroize( void *v, size_t n ) {
    volatile unsigned char *p = v; while( n-- ) *p++ = 0;
}

/*
 * Initialize a context
 */
void mbedtls_aegis_init( mbedtls_aegis_context *ctx )
{
    memset( ctx, 0, sizeof( mbedtls_aegis_context ) );
}

int mbedtls_aegis_setkey( mbedtls_aegis_context *ctx, const unsigned char *key, unsigned int keybits )
{
    if ( NULL == ctx )
        return MBEDTLS_ERR_AEGIS_BAD_INPUT;

    if ( 128 != keybits )
      return MBEDTLS_ERR_AEGIS_INVALID_KEY_LENGTH;

    memcpy(ctx->key, key, 16);

    return( 0 );
}

/* Use AES software implementation */

#if !defined(MBEDTLS_AESNI_C)
void AESROUND(unsigned char *out, unsigned char *in, unsigned char *rk)
{
    out[0] = ((uint32_t *)TE0)[*(in+0)]  ^ ((uint32_t *)TE1)[*(in+5)]  ^ ((uint32_t *)TE2)[*(in+10)] ^ ((uint32_t *)TE3)[*(in+15)] ^ rk[0];
    out[1] = ((uint32_t *)TE0)[*(in+4)]  ^ ((uint32_t *)TE1)[*(in+9)]  ^ ((uint32_t *)TE2)[*(in+14)] ^ ((uint32_t *)TE3)[*(in+3)]  ^ rk[1];
    out[2] = ((uint32_t *)TE0)[*(in+8)]  ^ ((uint32_t *)TE1)[*(in+13)] ^ ((uint32_t *)TE2)[*(in+2)]  ^ ((uint32_t *)TE3)[*(in+7)]  ^ rk[2];
    out[3] = ((uint32_t *)TE0)[*(in+12)] ^ ((uint32_t *)TE1)[*(in+1)]  ^ ((uint32_t *)TE2)[*(in+6)]  ^ ((uint32_t *)TE3)[*(in+11)] ^ rk[3];
}

#define XOR128(x,y,z) {                                                  \
    ((unsigned long long *)(x))[0] = ((unsigned long long *)(y))[0] ^ ((unsigned long long *)(z))[0];  \
    ((unsigned long long *)(x))[1] = ((unsigned long long *)(y))[1] ^ ((unsigned long long *)(z))[1];  \
}

#define AND128(x,y,z) {                                                  \
    ((unsigned long long *)(x))[0] = ((unsigned long long *)(y))[0] & ((unsigned long long *)(z))[0];  \
    ((unsigned long long *)(x))[1] = ((unsigned long long *)(y))[1] & ((unsigned long long *)(z))[1];  \
}

void mbedtls_aegis_setup( mbedtls_aegis_context *ctx, const unsigned char *iv )
{
    int i;
    unsigned char tmp[16];
    unsigned char key_tmp[16];
    unsigned char iv_tmp[16];
    memcpy(key_tmp, ctx->key, 16);
    memcpy(iv_tmp, iv, 16);

    XOR128(ctx->state,  key_tmp,  iv_tmp);
    memcpy(ctx->state+16, constant+16, 16);
    memcpy(ctx->state+32, constant,    16);
    memcpy(ctx->state+48, constant+16, 16);
    XOR128(ctx->state+64, key_tmp, iv_tmp);
    XOR128(ctx->state+80, key_tmp, constant);
    XOR128(ctx->state+96, key_tmp, constant+16);
    XOR128(ctx->state+112,key_tmp, constant);

    for (i = 0; i < 10; i++)  {
          //ctx->state update function;
          memcpy(tmp, ctx->state+112, 16);

          AESROUND(ctx->state+112,ctx->state+96, ctx->state+112);
          AESROUND(ctx->state+96, ctx->state+80, ctx->state+96);
          AESROUND(ctx->state+80, ctx->state+64, ctx->state+80);
          AESROUND(ctx->state+64, ctx->state+48, ctx->state+64);
          AESROUND(ctx->state+48, ctx->state+32, ctx->state+48);
          AESROUND(ctx->state+32, ctx->state+16, ctx->state+32);
          AESROUND(ctx->state+16, ctx->state+0,  ctx->state+16);
          AESROUND(ctx->state+0,  tmp,      ctx->state+0);

          //message is used to update the ctx->state.
          XOR128(ctx->state, ctx->state, iv_tmp);
          XOR128(ctx->state+64, ctx->state+64, key_tmp);
    }
}

void mbedtls_aegis_crypto_auth_step(mbedtls_aegis_context *ctx, int mode, const unsigned char *input, unsigned char *output)
{
    unsigned char tmp[16];

    AND128(output, ctx->state+32, ctx->state+48);
    XOR128(output, output, ctx->state+16);
    XOR128(output, output, ctx->state+96);
    XOR128(output, output, input);

    AND128(output+16, ctx->state+96, ctx->state+112);
    XOR128(output+16, output+16, ctx->state+32);
    XOR128(output+16, output+16, ctx->state+80);
    XOR128(output+16, output+16, input+16);

    memcpy(tmp, ctx->state+112, 16);
    AESROUND(ctx->state+112,ctx->state+96, ctx->state+112);
    AESROUND(ctx->state+96, ctx->state+80, ctx->state+96);
    AESROUND(ctx->state+80, ctx->state+64, ctx->state+80);
    AESROUND(ctx->state+64, ctx->state+48, ctx->state+64);
    AESROUND(ctx->state+48, ctx->state+32, ctx->state+48);
    AESROUND(ctx->state+32, ctx->state+16, ctx->state+32);
    AESROUND(ctx->state+16, ctx->state+0,  ctx->state+16);
    AESROUND(ctx->state+0,  tmp,      ctx->state+0);

    if(MBEDTLS_AEGIS_ENCRYPT == mode)
    {
        XOR128(ctx->state, ctx->state, input);
        XOR128(ctx->state+64, ctx->state+64, input+16);
    }
    else
    {
        XOR128(ctx->state, ctx->state, output);
        XOR128(ctx->state+64, ctx->state+64, output+16);
    }
}

/* The finalization state of AEGIS */
void mbedtls_aegis_tag_generation( mbedtls_aegis_context *ctx, unsigned char *tag, unsigned long tag_len )
{
    int i;
    unsigned long len = ctx->len;
    unsigned long add_len = ctx->add_len;
    unsigned char tmp[16];
    unsigned char msg_tmp[16];

    ((unsigned long long *)msg_tmp)[0] = add_len << 3;
    ((unsigned long long *)msg_tmp)[1] = len << 3;

    XOR128(msg_tmp, msg_tmp, ctx->state+32);

    for (i = 0; i < 7; i++) {
        //state update function
        memcpy(tmp, ctx->state+112, 16);

        AESROUND(ctx->state+112,ctx->state+96, ctx->state+112);
        AESROUND(ctx->state+96, ctx->state+80, ctx->state+96);
        AESROUND(ctx->state+80, ctx->state+64, ctx->state+80);
        AESROUND(ctx->state+64, ctx->state+48, ctx->state+64);
        AESROUND(ctx->state+48, ctx->state+32, ctx->state+48);
        AESROUND(ctx->state+32, ctx->state+16, ctx->state+32);
        AESROUND(ctx->state+16, ctx->state+0,  ctx->state+16);
        AESROUND(ctx->state+0,  tmp,      ctx->state+0);

        //message is used to update the state.
        XOR128(ctx->state,    ctx->state,    msg_tmp);
        XOR128(ctx->state+64, ctx->state+64, msg_tmp);
    }

    XOR128(ctx->state+96, ctx->state+96, ctx->state+80);
    XOR128(ctx->state+96, ctx->state+96, ctx->state+64);
    XOR128(ctx->state+96, ctx->state+96, ctx->state+48);
    XOR128(ctx->state+96, ctx->state+96, ctx->state+32);
    XOR128(ctx->state+96, ctx->state+96, ctx->state+16);
    XOR128(ctx->state+96, ctx->state+96, ctx->state+0);

    //in this program, the mac length is assumed to be multiple of bytes
    memcpy(tag, ctx->state+96, tag_len);
    ctx->len = len + 16;
}

#else /* AES-NI Implementation of AEGIS */

void mbedtls_aegis_setup( mbedtls_aegis_context *ctx, const unsigned char *iv )
{
    int i;
    __m128i  tmp;
    __m128i  key_tmp = _mm_loadu_si128 ( ( __m128i * ) ctx->key );
    __m128i  iv_tmp  = _mm_loadu_si128 ( ( __m128i * ) iv );

    ctx->state[0] = _mm_xor_si128(key_tmp, iv_tmp);
    ctx->state[1] = _mm_set_epi8(0xdd,0x28,0xb5,0x73,0x42,0x31,0x11,0x20,0xf1,0x2f,0xc2,0x6d,0x55,0x18,0x3d,0xdb);
    ctx->state[2] = _mm_set_epi8(0x62,0x79,0xe9,0x90,0x59,0x37,0x22,0x15,0x0d,0x08,0x05,0x03,0x02,0x01,0x1, 0x0);
    ctx->state[3] = _mm_set_epi8(0xdd,0x28,0xb5,0x73,0x42,0x31,0x11,0x20,0xf1,0x2f,0xc2,0x6d,0x55,0x18,0x3d,0xdb);
    ctx->state[4] = _mm_xor_si128(key_tmp, iv_tmp);
    ctx->state[5] = _mm_xor_si128(key_tmp, _mm_set_epi8(0x62,0x79,0xe9,0x90,0x59,0x37,0x22,0x15,0x0d,0x08,0x05,0x03,0x02,0x01,0x1,0x0));
    ctx->state[6] = _mm_xor_si128(key_tmp, _mm_set_epi8(0xdd,0x28,0xb5,0x73,0x42,0x31,0x11,0x20,0xf1,0x2f,0xc2,0x6d,0x55,0x18,0x3d,0xdb));
    ctx->state[7] = _mm_xor_si128(key_tmp, _mm_set_epi8(0x62,0x79,0xe9,0x90,0x59,0x37,0x22,0x15,0x0d,0x08,0x05,0x03,0x02,0x01,0x1,0x0));

    for (i = 0; i < 10; i++)
    {
        //state update function;
        tmp = ctx->state[7];
        ctx->state[7] = _mm_aesenc_si128(ctx->state[6],ctx->state[7]);
        ctx->state[6] = _mm_aesenc_si128(ctx->state[5],ctx->state[6]);
        ctx->state[5] = _mm_aesenc_si128(ctx->state[4],ctx->state[5]);
        ctx->state[4] = _mm_aesenc_si128(ctx->state[3],ctx->state[4]);
        ctx->state[3] = _mm_aesenc_si128(ctx->state[2],ctx->state[3]);
        ctx->state[2] = _mm_aesenc_si128(ctx->state[1],ctx->state[2]);
        ctx->state[1] = _mm_aesenc_si128(ctx->state[0],ctx->state[1]);
        ctx->state[0] = _mm_aesenc_si128(tmp,ctx->state[0]);

        //message is used to update the ctx->state.
        ctx->state[0] = _mm_xor_si128(ctx->state[0],iv_tmp);
        ctx->state[4] = _mm_xor_si128(ctx->state[4],key_tmp);
    }
}

void mbedtls_aegis_crypto_auth_step(mbedtls_aegis_context *ctx, int mode, const unsigned char *input, unsigned char *output)
{
    __m128i ct0,ct1;
    __m128i tmp;
    __m128i msg0 = _mm_load_si128((__m128i*)input);
    __m128i msg1 = _mm_load_si128((__m128i*)(input+16));

    ct0 = _mm_xor_si128(msg0, ctx->state[6]);
    ct0 = _mm_xor_si128(ct0,  ctx->state[1]);
    ct1 = _mm_xor_si128(msg1, ctx->state[2]);
    ct1 = _mm_xor_si128(ct1,  ctx->state[5]);
    ct0 = _mm_xor_si128(ct0,  _mm_and_si128(ctx->state[2], ctx->state[3]));
    ct1 = _mm_xor_si128(ct1,  _mm_and_si128(ctx->state[6], ctx->state[7]));
    _mm_store_si128((__m128i*)output, ct0);
    _mm_store_si128((__m128i*)(output+16), ct1);

    tmp = ctx->state[7];
    ctx->state[7] = _mm_aesenc_si128(ctx->state[6],ctx->state[7]);
    ctx->state[6] = _mm_aesenc_si128(ctx->state[5],ctx->state[6]);
    ctx->state[5] = _mm_aesenc_si128(ctx->state[4],ctx->state[5]);
    ctx->state[4] = _mm_aesenc_si128(ctx->state[3],ctx->state[4]);
    ctx->state[3] = _mm_aesenc_si128(ctx->state[2],ctx->state[3]);
    ctx->state[2] = _mm_aesenc_si128(ctx->state[1],ctx->state[2]);
    ctx->state[1] = _mm_aesenc_si128(ctx->state[0],ctx->state[1]);
    ctx->state[0] = _mm_aesenc_si128(tmp,ctx->state[0]);

    if(MBEDTLS_AEGIS_ENCRYPT == mode)
    {
        ctx->state[0] = _mm_xor_si128(ctx->state[0],msg0);
        ctx->state[4] = _mm_xor_si128(ctx->state[4],msg1);
    }
    else
    {
        msg0 = _mm_load_si128((__m128i*)output);
        msg1 = _mm_load_si128((__m128i*)(output+16));
        ctx->state[0] = _mm_xor_si128(ctx->state[0],msg0);
        ctx->state[4] = _mm_xor_si128(ctx->state[4],msg1);
    }
}

void mbedtls_aegis_tag_generation( mbedtls_aegis_context *ctx, unsigned char *tag, unsigned long tag_len )
{
    int i;
    unsigned long len;
    unsigned long add_len;
    __m128i tmp;
    __m128i msg_tmp;
    unsigned char t[16],tt[16];

    len = ctx->len;
    add_len = ctx->add_len;

    memset( tt, 0, sizeof( tt ) );

    ((unsigned long long*)tt)[0] = add_len << 3;
    ((unsigned long long*)tt)[1] = len << 3;
    msg_tmp = _mm_load_si128((__m128i*)tt);

    msg_tmp = _mm_xor_si128(msg_tmp, ctx->state[2]);

    for (i = 0; i < 7; i++)
    {
         tmp = ctx->state[7];
         ctx->state[7] = _mm_aesenc_si128(ctx->state[6],ctx->state[7]);
         ctx->state[6] = _mm_aesenc_si128(ctx->state[5],ctx->state[6]);
         ctx->state[5] = _mm_aesenc_si128(ctx->state[4],ctx->state[5]);
         ctx->state[4] = _mm_aesenc_si128(ctx->state[3],ctx->state[4]);
         ctx->state[3] = _mm_aesenc_si128(ctx->state[2],ctx->state[3]);
         ctx->state[2] = _mm_aesenc_si128(ctx->state[1],ctx->state[2]);
         ctx->state[1] = _mm_aesenc_si128(ctx->state[0],ctx->state[1]);
         ctx->state[0] = _mm_aesenc_si128(tmp,ctx->state[0]);

         ctx->state[0] = _mm_xor_si128(ctx->state[0],msg_tmp);
         ctx->state[4] = _mm_xor_si128(ctx->state[4],msg_tmp);
    }

    ctx->state[6] = _mm_xor_si128(ctx->state[6], ctx->state[5]);
    ctx->state[6] = _mm_xor_si128(ctx->state[6], ctx->state[4]);
    ctx->state[6] = _mm_xor_si128(ctx->state[6], ctx->state[3]);
    ctx->state[6] = _mm_xor_si128(ctx->state[6], ctx->state[2]);
    ctx->state[6] = _mm_xor_si128(ctx->state[6], ctx->state[1]);
    ctx->state[6] = _mm_xor_si128(ctx->state[6], ctx->state[0]);

    _mm_store_si128( (__m128i*)t, ctx->state[6] );

    memcpy( tag, t, tag_len );
    ctx->len = len + 16;
}

#endif /* !defined(MBEDTLS_AESNI_C) */

int mbedtls_aegis_starts( mbedtls_aegis_context *ctx,
                const unsigned char *iv,
                size_t iv_len,
                const unsigned char *add,
                size_t add_len )
{
    unsigned char buffer1[32], buffer2[32];
    size_t i;

    /* IV and AD are limited to 2^64 bits, so 2^61 bytes */
    /* IV is not allowed to be zero length */
    if( iv_len == 0 ||
      ( (uint64_t) iv_len  ) >> 61 != 0 ||
      ( (uint64_t) add_len ) >> 61 != 0 )
    {
        return( MBEDTLS_ERR_AEGIS_BAD_INPUT );
    }

    ctx->len = 0;
    ctx->add_len = add_len;

    // Initialize aegis state
    mbedtls_aegis_setup( ctx, iv );

    //process the associated data
    for (i = 0; (i + 32) <= add_len; i += 32) {
          mbedtls_aegis_crypto_auth_step(ctx, MBEDTLS_AEGIS_ENCRYPT, add + i, buffer2);
    }

    //deal with the partial block of associated data
    //in this program, we assume that the message length is multiple of bytes.
    if ( (add_len & 0x1f) != 0 )  {
          memset(buffer1, 0, 32);
          memcpy(buffer1, add + i, add_len & 0x1f);
          mbedtls_aegis_crypto_auth_step(ctx, MBEDTLS_AEGIS_ENCRYPT, buffer1, buffer2);
    }

    return( 0 );
}

int mbedtls_aegis_update( mbedtls_aegis_context *ctx,
                int mode,
                size_t length,
                const unsigned char *input,
                unsigned char *output )
{
    unsigned char buffer1[32], buffer2[32];
    unsigned int i;

    // encrypt/decrypt the input
    for (i = 0; (i + 32) <= length; i += 32) {
          mbedtls_aegis_crypto_auth_step(ctx, mode, input + i, output + i);
    }

    // Deal with the partial block
    // In this program, we assume that the message length is multiple of bytes.
    if ((length & 0x1f) != 0)
    {
        memset(buffer1, 0, 32);
        memcpy(buffer1, input + i, length & 0x1f);
        mbedtls_aegis_crypto_auth_step(ctx, mode, buffer1, buffer2);
        memcpy(output + i, buffer2, length & 0x1f);

        if (MBEDTLS_AEGIS_DECRYPT == mode)
        {
          //need to modify the state here (because in the last block, keystream is wrongly used to update the state)
          memset(buffer2, 0, length & 0x1f);

#if !defined(MBEDTLS_AESNI_C)
          XOR128(ctx->state, ctx->state, buffer2);
          XOR128(ctx->state+64, ctx->state+64, buffer2 + 16);
#else
          ctx->state[0] = _mm_xor_si128( ctx->state[0], _mm_load_si128((__m128i*)buffer2)  ) ;
          ctx->state[4] = _mm_xor_si128( ctx->state[4], _mm_load_si128((__m128i*)(buffer2 + 16) )  ) ;
#endif
        }
    }

    if( output > input && (size_t) ( output - input ) < length )
        return( MBEDTLS_ERR_AEGIS_BAD_INPUT );

    /* Total length is restricted to 2^39 - 256 bits, ie 2^36 - 2^5 bytes
     * Also check for possible overflow */
    if( ctx->len + length < ctx->len || (uint64_t) ctx->len + length > 0xFFFFFFFE0ull )
    {
        return( MBEDTLS_ERR_AEGIS_BAD_INPUT );
    }

    ctx->len += length;

    return( 0 );
}

int mbedtls_aegis_finish( mbedtls_aegis_context *ctx, unsigned char *tag, size_t tag_len )
{
    if( tag_len != 16 )
        return( MBEDTLS_ERR_AEGIS_BAD_INPUT );

    //we assume that the tag length is multiple of bytes
    mbedtls_aegis_tag_generation(ctx, tag, tag_len);

    return( 0 );
}

int mbedtls_aegis_crypt_and_tag( mbedtls_aegis_context *ctx,
                       int mode,
                       size_t length,
                       const unsigned char *iv,
                       size_t iv_len,
                       const unsigned char *add,
                       size_t add_len,
                       const unsigned char *input,
                       unsigned char *output,
                       size_t tag_len,
                       unsigned char *tag )
{
    int ret;

    if( ( ret = mbedtls_aegis_starts( ctx, iv, iv_len, add, add_len ) ) != 0 )
        return( ret );

    if( ( ret = mbedtls_aegis_update( ctx, mode, length, input, output ) ) != 0 )
        return( ret );

    if( ( ret = mbedtls_aegis_finish( ctx, tag, tag_len ) ) != 0 )
        return( ret );

    return( 0 );
}

int mbedtls_aegis_auth_decrypt( mbedtls_aegis_context *ctx,
                      size_t length,
                      const unsigned char *iv,
                      size_t iv_len,
                      const unsigned char *add,
                      size_t add_len,
                      const unsigned char *tag,
                      size_t tag_len,
                      const unsigned char *input,
                      unsigned char *output )
{
    int ret;
    unsigned char check_tag[16];
    size_t i;
    int diff;

    if( ( ret = mbedtls_aegis_crypt_and_tag( ctx, MBEDTLS_AEGIS_DECRYPT, length,
                                   iv, iv_len, add, add_len,
                                   input, output, tag_len, check_tag ) ) != 0 )
    {
        return( ret );
    }

    /* Check tag in "constant-time" */
    for( diff = 0, i = 0; i < tag_len; i++ )
        diff |= tag[i] ^ check_tag[i];

    if( diff != 0 )
    {
        mbedtls_zeroize( output, length );
        return( MBEDTLS_ERR_AEGIS_AUTH_FAILED );
    }

    return( 0 );
}

void mbedtls_aegis_free( mbedtls_aegis_context *ctx )
{
    if( ctx == NULL )
        return;

    mbedtls_zeroize( ctx, sizeof( mbedtls_aegis_context ) );
}

#if defined(MBEDTLS_SELF_TEST) && defined(MBEDTLS_AEGIS_C)
/*
 * AEGIS test vectors from:
 *
 * https://eprint.iacr.org/2013/695.pdf
 */
#define MAX_TESTS 4

static const int test_key_index[MAX_TESTS] =
     { 0, 0, 1, 2 };

static const unsigned char test_key[MAX_TESTS][16] =
{
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
};

static const long long unsigned int test_iv_len[MAX_TESTS] =
    { 16, 16, 16, 16 };

static const int test_iv_index[MAX_TESTS] =
    { 0, 0, 1, 2 };

static const unsigned char test_iv[MAX_TESTS][16] =
{
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x10, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
};

static const long long unsigned int test_add_len[MAX_TESTS] =
    { 0, 16, 4, 8 };

static const int test_add_index[MAX_TESTS] =
    { 0, 1, 2, 3 };

static const unsigned char test_add[MAX_TESTS][16] =
{
    { 0x00 },
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x01, 0x02, 0x03 },
    { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07 }
};

static const long long unsigned int test_pt_len[MAX_TESTS] =
    { 16, 16, 16, 32 };

static const int test_pt_index[MAX_TESTS] =
    { 0, 0, 0, 1 };

static const unsigned char test_pt[MAX_TESTS][32] =
{
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
      0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
      0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
      0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f }
};

static const unsigned char test_ct[MAX_TESTS][32] =
{
    { 0x41, 0xde, 0x90, 0x00, 0xa7, 0xb5, 0xe4, 0x0e,
      0x2d, 0x68, 0xbb, 0x64, 0xd9, 0x9e, 0xbb, 0x19 },
    { 0x29, 0xa0, 0xce, 0x1f, 0x5d, 0xce, 0x8c, 0x40,
      0x4d, 0x56, 0xd0, 0x04, 0x91, 0x66, 0x86, 0x04 },
    { 0x1c, 0x0f, 0x22, 0x9f, 0x28, 0x98, 0x44, 0xde,
      0xf2, 0xc1, 0xef, 0x28, 0xbe, 0xa0, 0xab, 0xf0 },
    { 0x79, 0xd9, 0x45, 0x93, 0xd8, 0xc2, 0x11, 0x9d,
      0x7e, 0x8f, 0xd9, 0xb8, 0xfc, 0x77, 0x84, 0x5c,
      0x5c, 0x07, 0x7a, 0x05, 0xb2, 0x52, 0x8b, 0x6a,
      0xc5, 0x4b, 0x56, 0x3a, 0xed, 0x8e, 0xfe, 0x84 }
};

static const unsigned char test_tag[MAX_TESTS][16] =
{
    { 0xf4, 0xd9, 0x97, 0xcc, 0x9b, 0x94, 0x22, 0x7a,
      0xda, 0x4f, 0xe4, 0x16, 0x54, 0x22, 0xb1, 0xc8 },
    { 0x29, 0xc9, 0xd9, 0x3a, 0xfd, 0x7e, 0x12, 0x76,
      0x11, 0x2a, 0x1f, 0xd0, 0xc3, 0x44, 0xcc, 0xd2 },
    { 0x1f, 0x07, 0x99, 0xd6, 0x88, 0x40, 0xd2, 0x36,
      0x4e, 0x7e, 0xec, 0xa6, 0xd4, 0x1b, 0x4d, 0x05 },
    { 0xcc, 0x6f, 0x33, 0x72, 0xf6, 0xaa, 0x1b, 0xb8,
      0x23, 0x88, 0xd6, 0x95, 0xc3, 0x96, 0x2d, 0x9a },
};

int mbedtls_aegis_self_test( int verbose )
{
    mbedtls_aegis_context ctx;
    unsigned char buf[48];
    unsigned char tag_buf[16];
    int i, ret;
    const size_t key_len = 128;

    for( i = 0; i < MAX_TESTS; i++ )
    {
        if( verbose != 0 )
            mbedtls_printf( "  AEGIS-128-L #%d (%s): ", i, "enc" );

        mbedtls_aegis_init( &ctx );

        mbedtls_aegis_setkey( &ctx, test_key[test_key_index[i]], key_len );

        ret = mbedtls_aegis_crypt_and_tag( &ctx, MBEDTLS_AEGIS_ENCRYPT,
                                 test_pt_len[i],
                                 test_iv[test_iv_index[i]], test_iv_len[i],
                                 test_add[test_add_index[i]], test_add_len[i],
                                 test_pt[test_pt_index[i]], buf, 16, tag_buf );

        if( ret != 0 ||
            memcmp( buf, test_ct[i], test_pt_len[i] ) != 0 ||
            memcmp( tag_buf, test_tag[i], 16 ) != 0 )
        {
            if( verbose != 0 )
                mbedtls_printf( "failed\n" );

            return( 1 );
        }

        mbedtls_aegis_free( &ctx );

        if( verbose != 0 )
            mbedtls_printf( "passed\n" );

        if( verbose != 0 )
            mbedtls_printf( "  AEGIS-128-L #%d (%s): ", i, "dec" );

        mbedtls_aegis_init( &ctx );

        mbedtls_aegis_setkey( &ctx, test_key[test_key_index[i]], key_len );

        ret = mbedtls_aegis_crypt_and_tag( &ctx, MBEDTLS_AEGIS_DECRYPT,
                                 test_pt_len[i],
                                 test_iv[test_iv_index[i]], test_iv_len[i],
                                 test_add[test_add_index[i]], test_add_len[i],
                                 test_ct[i], buf, 16, tag_buf );

        if( ret != 0 ||
            memcmp( buf, test_pt[test_pt_index[i]], test_pt_len[i] ) != 0 ||
            memcmp( tag_buf, test_tag[i], 16 ) != 0 )
        {
            if( verbose != 0 )
                mbedtls_printf( "failed\n" );

            return( 1 );
        }

        if( verbose != 0 )
            mbedtls_printf( "passed\n" );

        mbedtls_aegis_free( &ctx );

        if( verbose != 0 )
            mbedtls_printf( "  AEGIS-128-L #%d split (%s): ", i, "enc" );

        mbedtls_aegis_init( &ctx );

        mbedtls_aegis_setkey( &ctx, test_key[test_key_index[i]], key_len );

        ret = mbedtls_aegis_starts( &ctx, test_iv[test_iv_index[i]], test_iv_len[i], test_add[test_add_index[i]], test_add_len[i] );
        if( ret != 0 )
        {
            if( verbose != 0 )
                mbedtls_printf( "failed\n" );

            return( 1 );
        }

        if( test_pt_len[i] > 32 )
        {
            size_t rest_len = test_pt_len[i] - 32;
            ret = mbedtls_aegis_update( &ctx, MBEDTLS_AEGIS_ENCRYPT, 32, test_pt[test_pt_index[i]], buf );
            if( ret != 0 )
            {
                if( verbose != 0 )
                    mbedtls_printf( "failed\n" );

                return( 1 );
            }

            ret = mbedtls_aegis_update( &ctx, MBEDTLS_AEGIS_ENCRYPT, rest_len, test_pt[test_pt_index[i]] + 32,
                              buf + 32 );
            if( ret != 0 )
            {
                if( verbose != 0 )
                    mbedtls_printf( "failed\n" );

                return( 1 );
            }
        }
        else
        {
            ret = mbedtls_aegis_update( &ctx, MBEDTLS_AEGIS_ENCRYPT, test_pt_len[i], test_pt[test_pt_index[i]], buf );
            if( ret != 0 )
            {
                if( verbose != 0 )
                    mbedtls_printf( "failed\n" );

                return( 1 );
            }
        }

        ret = mbedtls_aegis_finish( &ctx, tag_buf, 16 );
        if( ret != 0 ||
            memcmp( buf, test_ct[i], test_pt_len[i] ) != 0 ||
            memcmp( tag_buf, test_tag[i], 16 ) != 0 )
        {
            if( verbose != 0 )
                mbedtls_printf( "failed\n" );

            return( 1 );
        }

        mbedtls_aegis_free( &ctx );

        if( verbose != 0 )
            mbedtls_printf( "passed\n" );

        if( verbose != 0 )
            mbedtls_printf( "  AEGIS-128-L #%d split (%s): ", i, "dec" );

        mbedtls_aegis_init( &ctx );

        mbedtls_aegis_setkey( &ctx, test_key[test_key_index[i]], key_len );

        ret = mbedtls_aegis_starts( &ctx, test_iv[test_iv_index[i]], test_iv_len[i], test_add[test_add_index[i]], test_add_len[i] );
        if( ret != 0 )
        {
            if( verbose != 0 )
                mbedtls_printf( "failed\n" );

            return( 1 );
        }

        if( test_pt_len[i] > 32 )
        {
            size_t rest_len = test_pt_len[i] - 32;
            ret = mbedtls_aegis_update( &ctx, MBEDTLS_AEGIS_DECRYPT, 32, test_ct[i], buf );
            if( ret != 0 )
            {
                if( verbose != 0 )
                    mbedtls_printf( "failed\n" );

                return( 1 );
            }

            ret = mbedtls_aegis_update( &ctx, MBEDTLS_AEGIS_DECRYPT, rest_len, test_ct[i] + 32,
                              buf + 32 );
            if( ret != 0 )
            {
                if( verbose != 0 )
                    mbedtls_printf( "failed\n" );

                return( 1 );
            }
        }
        else
        {
            ret = mbedtls_aegis_update( &ctx, MBEDTLS_AEGIS_DECRYPT, test_pt_len[i], test_ct[i], buf );
            if( ret != 0 )
            {
                if( verbose != 0 )
                    mbedtls_printf( "failed\n" );

                return( 1 );
            }
        }

        ret = mbedtls_aegis_finish( &ctx, tag_buf, 16 );
        if( ret != 0 ||
            memcmp( buf, test_pt[test_pt_index[i]], test_pt_len[i] ) != 0 ||
            memcmp( tag_buf, test_tag[i], 16 ) != 0 )
        {
            if( verbose != 0 )
                mbedtls_printf( "failed\n" );

            return( 1 );
        }

        mbedtls_aegis_free( &ctx );

        if( verbose != 0 )
            mbedtls_printf( "passed\n" );

    }

    if( verbose != 0 )
        mbedtls_printf( "\n" );

    return( 0 );
}

#endif /* MBEDTLS_SELF_TEST && MBEDTLS_AEGIS_C */

#endif /* MBEDTLS_AEGIS_C */
